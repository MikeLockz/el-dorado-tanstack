name: E2E Load Tests

on:
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Base API URL (e.g. http://localhost:4000 or public URL)'
        required: false
        default: 'https://eldorado.lockdev.com' 
      ws_url:
        description: 'Base WS URL (e.g. ws://localhost:4000/ws)'
        required: false
        default: 'wss://eldorado.lockdev.com/ws'
      players:
        description: 'Number of players per room'
        default: '4'
      concurrency:
        description: 'Concurrent rooms'
        default: '1'
  schedule:
    - cron: '0 */6 * * *' # Run every 6 hours (4x daily)
  workflow_run:
    workflows: ["Self-Hosted Production Deploy"]
    types:
      - completed

jobs:
  load-test:
    # Only run if the deploy was successful (for workflow_run trigger)
    if: "${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}"
    runs-on: [self-hosted, docker-deploy]
    
    env:
      # Logic: Use input if provided, else secret, else default local
      # We set these as step-level env vars or use a script to resolve them because
      # GitHub Actions context expansion is limited in the 'env' block.
      # We will resolve them in the "Run Artillery" step.
      DEFAULT_API_URL: ${{ secrets.VITE_API_URL }}
      DEFAULT_WS_URL: ${{ secrets.VITE_WS_URL }}
      
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v3
        with:
          version: 9
          
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Build Domain Package
        run: pnpm --filter @game/domain build
        
      - name: Resolve Configuration
        id: config
        run: |
          # Determine API_BASE_URL
          if [ -n "${{ inputs.target_url }}" ]; then
            echo "API_BASE_URL=${{ inputs.target_url }}" >> $GITHUB_ENV
          elif [ -n "$DEFAULT_API_URL" ]; then
             echo "API_BASE_URL=$DEFAULT_API_URL" >> $GITHUB_ENV
          else
             echo "API_BASE_URL=http://localhost:3001" >> $GITHUB_ENV
          fi
          
          # Determine WS_URL
          if [ -n "${{ inputs.ws_url }}" ]; then
            echo "WS_URL=${{ inputs.ws_url }}" >> $GITHUB_ENV
          elif [ -n "$DEFAULT_WS_URL" ]; then
             echo "WS_URL=$DEFAULT_WS_URL" >> $GITHUB_ENV
          else
             echo "WS_URL=ws://localhost:3001/ws" >> $GITHUB_ENV
          fi

      - name: Run Artillery
        id: artillery
        env:
          PLAYERS: ${{ inputs.players || 4 }}
          CONCURRENCY: ${{ inputs.concurrency || 1 }}
          ARTILLERY_RECORD_OUTPUT: 'true'
          IS_LOAD_TEST: 'true'
        run: |
          echo "Targeting API: $API_BASE_URL"
          echo "Targeting WS: $WS_URL"
          
          ./scripts/run-artillery.sh \
            --players=$PLAYERS \
            --concurrency=$CONCURRENCY \
            --repetitions=1

      - name: Publish Job Summary
        if: always()
        run: |
          echo "## Artillery Load Test Results" >> $GITHUB_STEP_SUMMARY
          
          JSON_FILE=$(find test-results -name "*.json" | head -n 1)
          if [ -f "$JSON_FILE" ]; then
            # Debug: Print keys to help diagnose if needed in logs
            # jq keys "$JSON_FILE"
            
            # Extract key metrics using jq with robust fallbacks
            SCENARIOS=$(jq '.aggregate.counters."vusers.created" // 0' "$JSON_FILE")
            COMPLETED=$(jq '.aggregate.counters."vusers.completed" // 0' "$JSON_FILE")
            
            # Session length (latency proxy for full user journey)
            LATENCY_P95=$(jq '.aggregate.summaries."vusers.session_length".p95 // 0' "$JSON_FILE")
            LATENCY_MAX=$(jq '.aggregate.summaries."vusers.session_length".max // 0' "$JSON_FILE")
            
            # HTTP Response time (might be null if only WS used, or named differently)
            HTTP_P95=$(jq '.aggregate.summaries."http.response_time".p95 // "N/A"' "$JSON_FILE")
            
            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "| :--- | :--- |" >> $GITHUB_STEP_SUMMARY
            echo "| **VUs Created** | $SCENARIOS |" >> $GITHUB_STEP_SUMMARY
            echo "| **VUs Completed** | $COMPLETED |" >> $GITHUB_STEP_SUMMARY
            echo "| **Session Duration P95** | ${LATENCY_P95}ms |" >> $GITHUB_STEP_SUMMARY
            echo "| **Session Duration Max** | ${LATENCY_MAX}ms |" >> $GITHUB_STEP_SUMMARY
            echo "| **HTTP Latency P95** | ${HTTP_P95} |" >> $GITHUB_STEP_SUMMARY
            
            # Check for failures
            FAILURES=$(jq '.aggregate.counters."vusers.failed" // 0' "$JSON_FILE")
            if [ "$FAILURES" -gt 0 ]; then
               echo "" >> $GITHUB_STEP_SUMMARY
               echo "### âš ï¸ Failures Detected" >> $GITHUB_STEP_SUMMARY
               echo "Failed VUs: **$FAILURES**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No results file found." >> $GITHUB_STEP_SUMMARY
          fi
            
      - name: Upload Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: artillery-results
          path: test-results/

      - name: Slack Notification on Failure
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          RUN_URL: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST -H 'Content-type: application/json' --data "{
              \"text\": \"ðŸš¨ *Artillery Load Test Failed!* \n\n*Environment:* Production\n*Run URL:* $RUN_URL\n*Reason:* One or more test scenarios failed to complete successfully.\"
            }" "$SLACK_WEBHOOK_URL"
          else
            echo "Warning: SLACK_WEBHOOK_URL secret is not set. Skipping notification."
          fi
