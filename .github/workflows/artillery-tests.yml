name: E2E Load Tests

on:
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Base API URL (e.g. http://localhost:4000 or public URL)'
        required: false
        default: 'http://localhost:3001' 
      ws_url:
        description: 'Base WS URL (e.g. ws://localhost:4000/ws)'
        required: false
        default: 'ws://localhost:3001/ws'
      players:
        description: 'Number of players per room'
        default: '4'
      concurrency:
        description: 'Concurrent rooms'
        default: '1'
      bots:
        description: 'Enable MCTS Bots (true/false)'
        required: false
        default: false
        type: boolean
  schedule:
    - cron: '0 */6 * * *' # Run every 6 hours (4x daily)
  workflow_run:
    workflows: ["Self-Hosted Production Deploy"]
    types:
      - completed

jobs:
  load-test:
    # Only run if the deploy was successful (for workflow_run trigger)
    if: "${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}"
    runs-on: [self-hosted, docker-deploy]
    
    env:
      # Logic: Use input if provided, else secret, else default local
      # We set these as step-level env vars or use a script to resolve them because
      # GitHub Actions context expansion is limited in the 'env' block.
      # We will resolve them in the "Run Artillery" step.
      DEFAULT_API_URL: ${{ secrets.VITE_API_URL }}
      DEFAULT_WS_URL: ${{ secrets.VITE_WS_URL }}
      
    steps:
      - uses: actions/checkout@v4
      
      - uses: pnpm/action-setup@v3
        with:
          version: 9
          
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        
      - name: Build Domain Package
        run: pnpm --filter @game/domain build
        
      - name: Resolve Configuration
        id: config
        run: |
          # Determine API_BASE_URL
          API_URL=""
          if [ -n "${{ inputs.target_url }}" ]; then
            API_URL="${{ inputs.target_url }}"
          # For post-deploy tests (workflow_run), prefer local direct connection for reliability
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
             API_URL="http://localhost:3001"
          elif [ -n "$DEFAULT_API_URL" ]; then
            API_URL="$DEFAULT_API_URL"
          else
             API_URL="http://localhost:3001"
          fi
          
          # Strip trailing slash if present
          API_URL=${API_URL%/}
          
          echo "API_BASE_URL=$API_URL" >> $GITHUB_ENV
          
          # Determine WS_URL
          WS_URL=""
          if [ -n "${{ inputs.ws_url }}" ]; then
            WS_URL="${{ inputs.ws_url }}"
          # For post-deploy tests (workflow_run), force derivation from the local API_URL
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
             WS_URL=$(echo "$API_URL" | sed 's/^http/ws/')
             WS_URL="${WS_URL}/ws"
          elif [ -n "$DEFAULT_WS_URL" ]; then
            WS_URL="$DEFAULT_WS_URL"
          else
             # Derive from API_URL (http -> ws, https -> wss) and append /ws
             WS_URL=$(echo "$API_URL" | sed 's/^http/ws/')
             WS_URL="${WS_URL}/ws"
          fi
          echo "WS_URL=$WS_URL" >> $GITHUB_ENV
          
          # Log the configuration (masking if not localhost to be safe, though public URLs aren't usually secrets)
          if [[ "$API_URL" == *"localhost"* ]]; then
            echo "Resolved Configuration (Local): API=$API_URL, WS=$WS_URL"
          else
            echo "Resolved Configuration (External): API=***, WS=***"
          fi

      - name: Wait for API to be ready
        run: |
          echo "Waiting for API at $API_BASE_URL/api/health"
          TIMEOUT=120
          START=$(date +%s)
          until curl -s "$API_BASE_URL/api/health" | grep -q "ok"; do
            NOW=$(date +%s)
            ELAPSED=$((NOW - START))
            if [ "$ELAPSED" -gt "$TIMEOUT" ]; then
              echo "Timeout waiting for API"
              echo "Last curl output (verbose):"
              curl -v "$API_BASE_URL/api/health" || true
              exit 1
            fi
            echo "API not ready yet. Retrying in 5s..."
            sleep 5
          done
          echo "API is ready!"

      - name: Run Artillery
        id: artillery
        env:
          PLAYERS: ${{ inputs.players || 4 }}
          CONCURRENCY: ${{ inputs.concurrency || 1 }}
          USE_BOTS: ${{ inputs.bots || 'false' }}
          ARTILLERY_RECORD_OUTPUT: 'true'
          IS_LOAD_TEST: 'true'
          NODE_TLS_REJECT_UNAUTHORIZED: '0'

        run: |
          echo "Targeting API: $API_BASE_URL"
          echo "Targeting WS: $WS_URL"
          echo "Bots Enabled: $USE_BOTS"
          
          ARGS=""
          if [ "$USE_BOTS" == "true" ]; then
            ARGS="--with-mcts-bots"
          fi

          ./scripts/run-artillery.sh \
            --players=$PLAYERS \
            --concurrency=$CONCURRENCY \
            --repetitions=1 \
            $ARGS

      - name: Publish Job Summary
        if: always()
        run: |
          echo "## Artillery Load Test Results" >> $GITHUB_STEP_SUMMARY
          
          JSON_FILE=$(find test-results -name "*.json" | head -n 1)
          if [ -f "$JSON_FILE" ]; then
            # Debug: Print keys to help diagnose if needed in logs
            # jq keys "$JSON_FILE"
            
            # Extract key metrics using jq with robust fallbacks
            SCENARIOS=$(jq '.aggregate.counters."vusers.created" // 0' "$JSON_FILE")
            COMPLETED=$(jq '.aggregate.counters."vusers.completed" // 0' "$JSON_FILE")
            
            # Session length (latency proxy for full user journey)
            LATENCY_P95=$(jq '.aggregate.summaries."vusers.session_length".p95 // 0' "$JSON_FILE")
            LATENCY_MAX=$(jq '.aggregate.summaries."vusers.session_length".max // 0' "$JSON_FILE")
            
            # HTTP Response time (might be null if only WS used, or named differently)
            HTTP_P95=$(jq '.aggregate.summaries."http.response_time".p95 // "N/A"' "$JSON_FILE")
            
            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "| :--- | :--- |" >> $GITHUB_STEP_SUMMARY
            echo "| **VUs Created** | $SCENARIOS |" >> $GITHUB_STEP_SUMMARY
            echo "| **VUs Completed** | $COMPLETED |" >> $GITHUB_STEP_SUMMARY
            echo "| **Session Duration P95** | ${LATENCY_P95}ms |" >> $GITHUB_STEP_SUMMARY
            echo "| **Session Duration Max** | ${LATENCY_MAX}ms |" >> $GITHUB_STEP_SUMMARY
            echo "| **HTTP Latency P95** | ${HTTP_P95} |" >> $GITHUB_STEP_SUMMARY
            
            # Check for failures
            FAILURES=$(jq '.aggregate.counters."vusers.failed" // 0' "$JSON_FILE")
            if [ "$FAILURES" -gt 0 ]; then
               echo "" >> $GITHUB_STEP_SUMMARY
               echo "### âš ï¸ Failures Detected" >> $GITHUB_STEP_SUMMARY
               echo "Failed VUs: **$FAILURES**" >> $GITHUB_STEP_SUMMARY
               echo "::error::Artillery tests failed with $FAILURES failed VUs"
               exit 1
            fi
          else
            echo "No results file found." >> $GITHUB_STEP_SUMMARY
          fi
            
      - name: Upload Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: artillery-results
          path: test-results/

      - name: Diagnostic Logs
        if: failure()
        run: |
          echo "Listing running containers:"
          docker ps
          
          echo "Logs for server container(s):"
          docker ps --format "{{.Names}}" | grep server | xargs -I {} sh -c 'echo "Logs for {}"; docker logs --tail 200 {}'

      - name: Slack Notification on Failure
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          RUN_URL: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST -H 'Content-type: application/json' --data "{
              \"text\": \"ðŸš¨ *Artillery Load Test Failed!* \n\n*Environment:* Production\n*Run URL:* $RUN_URL\n*Reason:* One or more test scenarios failed to complete successfully.\"
            }" "$SLACK_WEBHOOK_URL"
          else
            echo "Warning: SLACK_WEBHOOK_URL secret is not set. Skipping notification."
          fi
