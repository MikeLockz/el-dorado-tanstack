name: Self-Hosted Production Deploy
on:
  # Trigger deployment on push to the 'main' branch
  push:
    branches:
      - main
  # Allow manual trigger via GitHub web UI
  workflow_dispatch:

jobs:
  deploy:
    # ðŸŽ¯ Targets your self-hosted Proxmox runner
    runs-on: [self-hosted, docker-deploy]

    # --- Environment Variables ---
    # These must be set as GitHub Secrets or Environment Variables
    env:
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      OBSERVABILITY_LXC_IP: ${{ secrets.OBSERVABILITY_LXC_IP }}
      VITE_API_URL: ${{ secrets.VITE_API_URL }}
      VITE_WS_URL: ${{ secrets.VITE_WS_URL }}
      # Add any other environment variables used by the stack here

    steps:
      - name: 1. Checkout Repository
        uses: actions/checkout@v4

      - name: 2. Set Up Docker Buildx (Optional but Recommended for Performance)
        # Use Docker Buildx to enable multi-stage/caching features
        uses: docker/setup-buildx-action@v3

      - name: 2.5 Pre-Clean Up (Free Disk Space)
        # Aggressively remove unused images/containers to prevent ENOSPC errors
        run: docker system prune -af

      - name: 3. Build Application Images
        # This command builds the 'web' and 'server' images defined in the compose file
        # It's better than running 'docker build' manually for each service.
        run: |
          docker compose \
            -f docker-compose.prod.yml \
            -f app-docker-compose-extension.yml \
            build \
            --build-arg VITE_API_URL="${VITE_API_URL}" \
            --build-arg VITE_WS_URL="${VITE_WS_URL}"

      - name: 3.5 Run database migrations
        # Apply Drizzle migrations against the self-hosted Postgres using the migrator container
        run: |
          docker compose \
            -f docker-compose.prod.yml \
            -f app-docker-compose-extension.yml \
            run --rm migrator

      - name: 3.9 Force Kill Port 8081
        run: |
          echo "Searching for containers on port 8081..."
          # Grep for 8081 in docker ps output to find any container using it
          CONTAINER_IDS=$(docker ps --format "{{.ID}} {{.Ports}}" | grep "0.0.0.0:8081" | awk '{print $1}')
          
          if [ ! -z "$CONTAINER_IDS" ]; then
            echo "Found container(s) using port 8081: $CONTAINER_IDS"
            echo "$CONTAINER_IDS" | xargs docker stop
            echo "$CONTAINER_IDS" | xargs docker rm
          else
            echo "No container found on port 8081."
          fi
          
          # Explicitly try to remove the named container if it exists but wasn't caught
          docker stop el-dorado-tanstack-web-1 || true
          docker rm el-dorado-tanstack-web-1 || true

      - name: 4. Deploy and Start Services
        # -d: Detached mode (run in the background)
        # --force-recreate: Ensures any existing containers are replaced with the newly built images
        run: |
          docker compose -f docker-compose.prod.yml -f app-docker-compose-extension.yml down --remove-orphans
          docker compose -f docker-compose.prod.yml -f app-docker-compose-extension.yml up -d --force-recreate

      - name: 5. Clean Up Old Images (Optional)
        # Removes old, dangling (unused) images to save disk space on your Proxmox host
        run: docker image prune -f
